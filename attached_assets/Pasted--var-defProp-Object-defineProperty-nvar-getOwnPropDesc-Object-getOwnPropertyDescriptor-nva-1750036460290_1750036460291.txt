"var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc2) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// server/db-sqlserver.ts\nimport sql from \"mssql\";\nasync function connectToSqlServer() {\n  if (!isConnected) {\n    try {\n      await pool2.connect();\n      console.log(\"Connected to SQL Server successfully\");\n      isConnected = true;\n    } catch (error) {\n      console.error(\"Failed to connect to SQL Server:\", error);\n      throw error;\n    }\n  }\n  return pool2;\n}\nasync function executeQuery(query, params = []) {\n  try {\n    await connectToSqlServer();\n    const request = pool2.request();\n    params.forEach((param, index2) => {\n      request.input(`param${index2}`, param);\n    });\n    const result = await request.query(query);\n    return result;\n  } catch (error) {\n    console.error(\"SQL Server query error:\", error);\n    throw error;\n  }\n}\nvar config, pool2, isConnected, SqlServerDatabase, sqlServerDb;\nvar init_db_sqlserver = __esm({\n  \"server/db-sqlserver.ts\"() {\n    \"use strict\";\n    config = {\n      user: process.env.SQL_SERVER_USER || \"\",\n      password: process.env.SQL_SERVER_PASSWORD || \"\",\n      server: process.env.SQL_SERVER_HOST || \"localhost\",\n      database: process.env.SQL_SERVER_DATABASE || \"FreelancingPlatform\",\n      port: parseInt(process.env.SQL_SERVER_PORT || \"1433\"),\n      options: {\n        encrypt: true,\n        trustServerCertificate: true\n      },\n      pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 3e4\n      }\n    };\n    pool2 = new sql.ConnectionPool(config);\n    isConnected = false;\n    SqlServerDatabase = class {\n      async query(sql3, params = []) {\n        return await executeQuery(sql3, params);\n      }\n      async getUsers() {\n        const result = await this.query(\"SELECT * FROM users ORDER BY created_at DESC\");\n        return result.recordset;\n      }\n      async getUserById(id) {\n        const result = await this.query(\"SELECT * FROM users WHERE id = @param0\", [id]);\n        return result.recordset[0];\n      }\n      async createUser(user) {\n        const query = `\n      INSERT INTO users (id, email, first_name, last_name, profile_image_url, user_type, title, bio, hourly_rate, skills, location, company)\n      VALUES (@param0, @param1, @param2, @param3, @param4, @param5, @param6, @param7, @param8, @param9, @param10, @param11)\n    `;\n        const params = [user.id, user.email, user.firstName, user.lastName, user.profileImageUrl, user.userType, user.title, user.bio, user.hourlyRate, JSON.stringify(user.skills), user.location, user.company];\n        return await this.query(query, params);\n      }\n      async getJobs() {\n        const result = await this.query(`\n      SELECT j.*, u.first_name + ' ' + u.last_name as client_name \n      FROM jobs j \n      INNER JOIN users u ON j.client_id = u.id \n      ORDER BY j.created_at DESC\n    `);\n        return result.recordset;\n      }\n      async createJob(job) {\n        const query = `\n      INSERT INTO jobs (title, description, client_id, status, budget_type, budget_min, budget_max, hourly_rate, category, experience_level, skills, remote)\n      VALUES (@param0, @param1, @param2, @param3, @param4, @param5, @param6, @param7, @param8, @param9, @param10, @param11)\n    `;\n        const params = [job.title, job.description, job.clientId, job.status, job.budgetType, job.budgetMin, job.budgetMax, job.hourlyRate, job.category, job.experienceLevel, JSON.stringify(job.skills), job.remote];\n        return await this.query(query, params);\n      }\n      async getProposals() {\n        const result = await this.query(`\n      SELECT p.*, j.title as job_title, u.first_name + ' ' + u.last_name as freelancer_name\n      FROM proposals p\n      INNER JOIN jobs j ON p.job_id = j.id\n      INNER JOIN users u ON p.freelancer_id = u.id\n      ORDER BY p.created_at DESC\n    `);\n        return result.recordset;\n      }\n      async createProposal(proposal) {\n        const query = `\n      INSERT INTO proposals (job_id, freelancer_id, cover_letter, proposed_rate, timeline, status)\n      VALUES (@param0, @param1, @param2, @param3, @param4, @param5)\n    `;\n        const params = [proposal.jobId, proposal.freelancerId, proposal.coverLetter, proposal.proposedRate, proposal.timeline, proposal.status];\n        return await this.query(query, params);\n      }\n    };\n    sqlServerDb = new SqlServerDatabase();\n    process.on(\"SIGINT\", async () => {\n      if (isConnected) {\n        await pool2.close();\n        console.log(\"SQL Server connection closed\");\n      }\n    });\n  }\n});\n\n// server/storage-sqlserver.ts\nvar storage_sqlserver_exports = {};\n__export(storage_sqlserver_exports, {\n  SqlServerStorage: () => SqlServerStorage,\n  sqlServerStorage: () => sqlServerStorage\n});\nvar SqlServerStorage, sqlServerStorage;\nvar init_storage_sqlserver = __esm({\n  \"server/storage-sqlserver.ts\"() {\n    \"use strict\";\n    init_db_sqlserver();\n    SqlServerStorage = class {\n      // User operations\n      async getUser(id) {\n        const result = await sqlServerDb.query(\"SELECT * FROM users WHERE id = @param0\", [id]);\n        const user = result.recordset[0];\n        if (user) {\n          return {\n            ...user,\n            skills: user.skills ? JSON.parse(user.skills) : [],\n            createdAt: new Date(user.created_at),\n            updatedAt: new Date(user.updated_at)\n          };\n        }\n        return void 0;\n      }\n      async upsertUser(userData) {\n        const existingUser = await this.getUser(userData.id);\n        if (existingUser) {\n          const query = `\n        UPDATE users SET \n          email = @param1,\n          first_name = @param2,\n          last_name = @param3,\n          profile_image_url = @param4,\n          user_type = @param5,\n          title = @param6,\n          bio = @param7,\n          hourly_rate = @param8,\n          skills = @param9,\n          location = @param10,\n          company = @param11,\n          updated_at = GETDATE()\n        WHERE id = @param0\n      `;\n          const params = [\n            userData.id,\n            userData.email,\n            userData.firstName,\n            userData.lastName,\n            userData.profileImageUrl,\n            userData.userType,\n            userData.title,\n            userData.bio,\n            userData.hourlyRate,\n            JSON.stringify(userData.skills || []),\n            userData.location,\n            userData.company\n          ];\n          await sqlServerDb.query(query, params);\n        } else {\n          const query = `\n        INSERT INTO users (id, email, first_name, last_name, profile_image_url, user_type, title, bio, hourly_rate, skills, location, company, created_at, updated_at)\n        VALUES (@param0, @param1, @param2, @param3, @param4, @param5, @param6, @param7, @param8, @param9, @param10, @param11, GETDATE(), GETDATE())\n      `;\n          const params = [\n            userData.id,\n            userData.email,\n            userData.firstName,\n            userData.lastName,\n            userData.profileImageUrl,\n            userData.userType,\n            userData.title,\n            userData.bio,\n            userData.hourlyRate,\n            JSON.stringify(userData.skills || []),\n            userData.location,\n            userData.company\n          ];\n          await sqlServerDb.query(query, params);\n        }\n        return await this.getUser(userData.id);\n      }\n      // Job operations\n      async createJob(job) {\n        const query = `\n      INSERT INTO jobs (title, description, client_id, status, budget_type, budget_min, budget_max, hourly_rate, category, experience_level, skills, remote, created_at, updated_at)\n      OUTPUT INSERTED.id\n      VALUES (@param0, @param1, @param2, 'open', @param3, @param4, @param5, @param6, @param7, @param8, @param9, @param10, GETDATE(), GETDATE())\n    `;\n        const params = [\n          job.title,\n          job.description,\n          job.clientId,\n          job.budgetType,\n          job.budgetMin,\n          job.budgetMax,\n          job.hourlyRate,\n          job.category,\n          job.experienceLevel,\n          JSON.stringify(job.skills || []),\n          job.remote ?? true\n        ];\n        const result = await sqlServerDb.query(query, params);\n        const jobId = result.recordset[0].id;\n        return await this.getJob(jobId);\n      }\n      async getJobs(filters = {}) {\n        let whereClause = \"\";\n        const params = [];\n        let paramIndex = 0;\n        if (filters.category) {\n          whereClause += ` AND j.category = @param${paramIndex}`;\n          params.push(filters.category);\n          paramIndex++;\n        }\n        if (filters.search) {\n          whereClause += ` AND (j.title LIKE @param${paramIndex} OR j.description LIKE @param${paramIndex})`;\n          params.push(`%${filters.search}%`);\n          paramIndex++;\n        }\n        const query = `\n      SELECT j.*, u.first_name + ' ' + ISNULL(u.last_name, '') as client_name\n      FROM jobs j\n      INNER JOIN users u ON j.client_id = u.id\n      WHERE 1=1 ${whereClause}\n      ORDER BY j.created_at DESC\n      OFFSET ${filters.offset || 0} ROWS\n      FETCH NEXT ${filters.limit || 50} ROWS ONLY\n    `;\n        const countQuery = `\n      SELECT COUNT(*) as total\n      FROM jobs j\n      WHERE 1=1 ${whereClause}\n    `;\n        const [jobsResult, countResult] = await Promise.all([\n          sqlServerDb.query(query, params),\n          sqlServerDb.query(countQuery, params)\n        ]);\n        const jobs2 = jobsResult.recordset.map((job) => ({\n          ...job,\n          skills: job.skills ? JSON.parse(job.skills) : [],\n          remote: Boolean(job.remote),\n          createdAt: new Date(job.created_at),\n          updatedAt: new Date(job.updated_at)\n        }));\n        return {\n          jobs: jobs2,\n          total: countResult.recordset[0].total\n        };\n      }\n      async getJob(id) {\n        const result = await sqlServerDb.query(\"SELECT * FROM jobs WHERE id = @param0\", [id]);\n        const job = result.recordset[0];\n        if (job) {\n          return {\n            ...job,\n            skills: job.skills ? JSON.parse(job.skills) : [],\n            remote: Boolean(job.remote),\n            createdAt: new Date(job.created_at),\n            updatedAt: new Date(job.updated_at)\n          };\n        }\n        return void 0;\n      }\n      async getJobWithClient(id) {\n        const query = `\n      SELECT j.*, u.id as client_id, u.email as client_email, u.first_name as client_first_name, \n             u.last_name as client_last_name, u.profile_image_url as client_profile_image_url\n      FROM jobs j\n      INNER JOIN users u ON j.client_id = u.id\n      WHERE j.id = @param0\n    `;\n        const result = await sqlServerDb.query(query, [id]);\n        const row = result.recordset[0];\n        if (row) {\n          const job = {\n            id: row.id,\n            title: row.title,\n            description: row.description,\n            clientId: row.client_id,\n            status: row.status,\n            budgetType: row.budget_type,\n            budgetMin: row.budget_min,\n            budgetMax: row.budget_max,\n            hourlyRate: row.hourly_rate,\n            category: row.category,\n            experienceLevel: row.experience_level,\n            skills: row.skills ? JSON.parse(row.skills) : [],\n            remote: Boolean(row.remote),\n            proposalCount: row.proposal_count,\n            createdAt: new Date(row.created_at),\n            updatedAt: new Date(row.updated_at)\n          };\n          const client2 = {\n            id: row.client_id,\n            email: row.client_email,\n            firstName: row.client_first_name,\n            lastName: row.client_last_name,\n            profileImageUrl: row.client_profile_image_url,\n            userType: \"client\",\n            skills: [],\n            createdAt: /* @__PURE__ */ new Date(),\n            updatedAt: /* @__PURE__ */ new Date()\n          };\n          return { ...job, client: client2 };\n        }\n        return void 0;\n      }\n      async updateJob(id, updates) {\n        const setClause = Object.keys(updates).map((key, index2) => `${key} = @param${index2 + 1}`).join(\", \");\n        const query = `UPDATE jobs SET ${setClause}, updated_at = GETDATE() WHERE id = @param0`;\n        const params = [id, ...Object.values(updates)];\n        await sqlServerDb.query(query, params);\n        return await this.getJob(id);\n      }\n      async deleteJob(id) {\n        await sqlServerDb.query(\"DELETE FROM jobs WHERE id = @param0\", [id]);\n      }\n      async getJobsByClient(clientId) {\n        const result = await sqlServerDb.query(\"SELECT * FROM jobs WHERE client_id = @param0 ORDER BY created_at DESC\", [clientId]);\n        return result.recordset.map((job) => ({\n          ...job,\n          skills: job.skills ? JSON.parse(job.skills) : [],\n          remote: Boolean(job.remote),\n          createdAt: new Date(job.created_at),\n          updatedAt: new Date(job.updated_at)\n        }));\n      }\n      // Proposal operations\n      async createProposal(proposal) {\n        const query = `\n      INSERT INTO proposals (job_id, freelancer_id, cover_letter, proposed_rate, timeline, status, created_at, updated_at)\n      OUTPUT INSERTED.id\n      VALUES (@param0, @param1, @param2, @param3, @param4, 'pending', GETDATE(), GETDATE())\n    `;\n        const params = [proposal.jobId, proposal.freelancerId, proposal.coverLetter, proposal.proposedRate, proposal.timeline];\n        const result = await sqlServerDb.query(query, params);\n        const proposalId = result.recordset[0].id;\n        return await this.getProposal(proposalId);\n      }\n      async getProposalsByJob(jobId) {\n        const query = `\n      SELECT p.*, u.first_name, u.last_name, u.email, u.profile_image_url\n      FROM proposals p\n      INNER JOIN users u ON p.freelancer_id = u.id\n      WHERE p.job_id = @param0\n      ORDER BY p.created_at DESC\n    `;\n        const result = await sqlServerDb.query(query, [jobId]);\n        return result.recordset.map((row) => ({\n          id: row.id,\n          jobId: row.job_id,\n          freelancerId: row.freelancer_id,\n          coverLetter: row.cover_letter,\n          proposedRate: row.proposed_rate,\n          timeline: row.timeline,\n          status: row.status,\n          createdAt: new Date(row.created_at),\n          updatedAt: new Date(row.updated_at),\n          freelancer: {\n            id: row.freelancer_id,\n            firstName: row.first_name,\n            lastName: row.last_name,\n            email: row.email,\n            profileImageUrl: row.profile_image_url,\n            userType: \"freelancer\",\n            skills: [],\n            createdAt: /* @__PURE__ */ new Date(),\n            updatedAt: /* @__PURE__ */ new Date()\n          }\n        }));\n      }\n      async getProposalsByFreelancer(freelancerId) {\n        const query = `\n      SELECT p.*, j.title, j.description, j.budget_type, j.budget_min, j.budget_max, j.hourly_rate\n      FROM proposals p\n      INNER JOIN jobs j ON p.job_id = j.id\n      WHERE p.freelancer_id = @param0\n      ORDER BY p.created_at DESC\n    `;\n        const result = await sqlServerDb.query(query, [freelancerId]);\n        return result.recordset.map((row) => ({\n          id: row.id,\n          jobId: row.job_id,\n          freelancerId: row.freelancer_id,\n          coverLetter: row.cover_letter,\n          proposedRate: row.proposed_rate,\n          timeline: row.timeline,\n          status: row.status,\n          createdAt: new Date(row.created_at),\n          updatedAt: new Date(row.updated_at),\n          job: {\n            id: row.job_id,\n            title: row.title,\n            description: row.description,\n            clientId: \"\",\n            status: \"open\",\n            budgetType: row.budget_type,\n            budgetMin: row.budget_min,\n            budgetMax: row.budget_max,\n            hourlyRate: row.hourly_rate,\n            category: \"\",\n            experienceLevel: \"intermediate\",\n            skills: [],\n            remote: true,\n            proposalCount: 0,\n            createdAt: /* @__PURE__ */ new Date(),\n            updatedAt: /* @__PURE__ */ new Date()\n          }\n        }));\n      }\n      async getProposal(id) {\n        const result = await sqlServerDb.query(\"SELECT * FROM proposals WHERE id = @param0\", [id]);\n        const proposal = result.recordset[0];\n        if (proposal) {\n          return {\n            id: proposal.id,\n            jobId: proposal.job_id,\n            freelancerId: proposal.freelancer_id,\n            coverLetter: proposal.cover_letter,\n            proposedRate: proposal.proposed_rate,\n            timeline: proposal.timeline,\n            status: proposal.status,\n            createdAt: new Date(proposal.created_at),\n            updatedAt: new Date(proposal.updated_at)\n          };\n        }\n        return void 0;\n      }\n      async updateProposal(id, updates) {\n        const setClause = Object.keys(updates).map((key, index2) => `${key} = @param${index2 + 1}`).join(\", \");\n        const query = `UPDATE proposals SET ${setClause}, updated_at = GETDATE() WHERE id = @param0`;\n        const params = [id, ...Object.values(updates)];\n        await sqlServerDb.query(query, params);\n        return await this.getProposal(id);\n      }\n      async deleteProposal(id) {\n        await sqlServerDb.query(\"DELETE FROM proposals WHERE id = @param0\", [id]);\n      }\n      // Stub implementations for remaining methods\n      async createMessage(message) {\n        throw new Error(\"Method not implemented yet\");\n      }\n      async getConversations(userId) {\n        return [];\n      }\n      async getMessagesBetweenUsers(user1Id, user2Id, limit) {\n        return [];\n      }\n      async markMessagesAsRead(receiverId, senderId) {\n      }\n      async getUnreadMessageCount(userId) {\n        return 0;\n      }\n      async createContract(contract) {\n        throw new Error(\"Method not implemented yet\");\n      }\n      async getContractsByFreelancer(freelancerId) {\n        return [];\n      }\n      async getContractsByClient(clientId) {\n        return [];\n      }\n      async updateContract(id, updates) {\n        throw new Error(\"Method not implemented yet\");\n      }\n      async getAllUsers(filters) {\n        const result = await sqlServerDb.query(\"SELECT * FROM users ORDER BY created_at DESC\");\n        const users2 = result.recordset.map((user) => ({\n          ...user,\n          skills: user.skills ? JSON.parse(user.skills) : [],\n          createdAt: new Date(user.created_at),\n          updatedAt: new Date(user.updated_at)\n        }));\n        return { users: users2, total: users2.length };\n      }\n      async getAllJobs(filters) {\n        const query = `\n      SELECT j.*, u.id as client_id, u.first_name as client_first_name, u.last_name as client_last_name, u.email as client_email\n      FROM jobs j\n      INNER JOIN users u ON j.client_id = u.id\n      ORDER BY j.created_at DESC\n    `;\n        const result = await sqlServerDb.query(query);\n        const jobs2 = result.recordset.map((row) => ({\n          id: row.id,\n          title: row.title,\n          description: row.description,\n          clientId: row.client_id,\n          status: row.status,\n          budgetType: row.budget_type,\n          budgetMin: row.budget_min,\n          budgetMax: row.budget_max,\n          hourlyRate: row.hourly_rate,\n          category: row.category,\n          experienceLevel: row.experience_level,\n          skills: row.skills ? JSON.parse(row.skills) : [],\n          remote: Boolean(row.remote),\n          proposalCount: row.proposal_count,\n          createdAt: new Date(row.created_at),\n          updatedAt: new Date(row.updated_at),\n          client: {\n            id: row.client_id,\n            firstName: row.client_first_name,\n            lastName: row.client_last_name,\n            email: row.client_email,\n            userType: \"client\",\n            skills: [],\n            createdAt: /* @__PURE__ */ new Date(),\n            updatedAt: /* @__PURE__ */ new Date()\n          }\n        }));\n        return { jobs: jobs2, total: jobs2.length };\n      }\n      async getAllProposals(filters) {\n        return { proposals: [], total: 0 };\n      }\n      async getAdminStats() {\n        const result = await sqlServerDb.query(\"SELECT * FROM admin_stats ORDER BY updated_at DESC\");\n        const stats = result.recordset[0];\n        if (stats) {\n          return {\n            id: stats.id,\n            totalUsers: stats.total_users,\n            totalJobs: stats.total_jobs,\n            totalProposals: stats.total_proposals,\n            totalContracts: stats.total_contracts,\n            totalRevenue: stats.total_revenue,\n            updatedAt: new Date(stats.updated_at)\n          };\n        }\n        return {\n          id: 1,\n          totalUsers: 0,\n          totalJobs: 0,\n          totalProposals: 0,\n          totalContracts: 0,\n          totalRevenue: 0,\n          updatedAt: /* @__PURE__ */ new Date()\n        };\n      }\n      async updateAdminStats() {\n      }\n      async suspendUser(suspension) {\n        throw new Error(\"Method not implemented yet\");\n      }\n      async unsuspendUser(userId) {\n      }\n      async getUserSuspensions(userId) {\n        return [];\n      }\n      async deleteUser(userId) {\n        await sqlServerDb.query(\"DELETE FROM users WHERE id = @param0\", [userId]);\n      }\n      async updateUserRole(userId, userType) {\n        await sqlServerDb.query(\"UPDATE users SET user_type = @param1, updated_at = GETDATE() WHERE id = @param0\", [userId, userType]);\n        return await this.getUser(userId);\n      }\n    };\n    sqlServerStorage = new SqlServerStorage();\n  }\n});\n\n// server/index.ts\nimport express2 from \"express\";\n\n// server/routes.ts\nimport { createServer } from \"http\";\n\n// shared/schema.ts\nvar schema_exports = {};\n__export(schema_exports, {\n  adminStats: () => adminStats,\n  contracts: () => contracts,\n  contractsRelations: () => contractsRelations,\n  insertContractSchema: () => insertContractSchema,\n  insertJobSchema: () => insertJobSchema,\n  insertMessageSchema: () => insertMessageSchema,\n  insertProposalSchema: () => insertProposalSchema,\n  insertSuspensionSchema: () => insertSuspensionSchema,\n  insertUserSchema: () => insertUserSchema,\n  jobs: () => jobs,\n  jobsRelations: () => jobsRelations,\n  messages: () => messages,\n  messagesRelations: () => messagesRelations,\n  proposals: () => proposals,\n  proposalsRelations: () => proposalsRelations,\n  sessions: () => sessions,\n  userSuspensions: () => userSuspensions,\n  users: () => users,\n  usersRelations: () => usersRelations\n});\nimport {\n  pgTable,\n  text,\n  varchar,\n  timestamp,\n  jsonb,\n  index,\n  serial,\n  integer,\n  decimal,\n  boolean\n} from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\nvar sessions = pgTable(\n  \"sessions\",\n  {\n    sid: varchar(\"sid\").primaryKey(),\n    sess: jsonb(\"sess\").notNull(),\n    expire: timestamp(\"expire\").notNull()\n  },\n  (table) => [index(\"IDX_session_expire\").on(table.expire)]\n);\nvar users = pgTable(\"users\", {\n  id: varchar(\"id\").primaryKey().notNull(),\n  email: varchar(\"email\").unique(),\n  firstName: varchar(\"first_name\"),\n  lastName: varchar(\"last_name\"),\n  profileImageUrl: varchar(\"profile_image_url\"),\n  userType: varchar(\"user_type\").notNull().default(\"client\"),\n  // 'freelancer', 'client', or 'admin'\n  title: varchar(\"title\"),\n  // Professional title for freelancers\n  bio: text(\"bio\"),\n  // Professional bio\n  hourlyRate: decimal(\"hourly_rate\", { precision: 10, scale: 2 }),\n  // For freelancers\n  skills: text(\"skills\").array(),\n  // Skills array for freelancers\n  location: varchar(\"location\"),\n  company: varchar(\"company\"),\n  // For clients\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  updatedAt: timestamp(\"updated_at\").defaultNow()\n});\nvar jobs = pgTable(\"jobs\", {\n  id: serial(\"id\").primaryKey(),\n  title: varchar(\"title\").notNull(),\n  description: text(\"description\").notNull(),\n  clientId: varchar(\"client_id\").notNull().references(() => users.id),\n  category: varchar(\"category\").notNull(),\n  budgetType: varchar(\"budget_type\").notNull(),\n  // 'fixed' or 'hourly'\n  budgetMin: decimal(\"budget_min\", { precision: 10, scale: 2 }),\n  budgetMax: decimal(\"budget_max\", { precision: 10, scale: 2 }),\n  hourlyRate: decimal(\"hourly_rate\", { precision: 10, scale: 2 }),\n  experienceLevel: varchar(\"experience_level\").notNull(),\n  // 'entry', 'intermediate', 'expert'\n  skills: text(\"skills\").array(),\n  status: varchar(\"status\").notNull().default(\"open\"),\n  // 'open', 'in_progress', 'completed', 'cancelled'\n  remote: boolean(\"remote\").default(true),\n  proposalCount: integer(\"proposal_count\").default(0),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  updatedAt: timestamp(\"updated_at\").defaultNow()\n});\nvar proposals = pgTable(\"proposals\", {\n  id: serial(\"id\").primaryKey(),\n  jobId: integer(\"job_id\").notNull().references(() => jobs.id),\n  freelancerId: varchar(\"freelancer_id\").notNull().references(() => users.id),\n  coverLetter: text(\"cover_letter\").notNull(),\n  proposedRate: decimal(\"proposed_rate\", { precision: 10, scale: 2 }),\n  timeline: varchar(\"timeline\"),\n  // Estimated timeline\n  status: varchar(\"status\").notNull().default(\"submitted\"),\n  // 'submitted', 'interviewing', 'accepted', 'rejected'\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  updatedAt: timestamp(\"updated_at\").defaultNow()\n});\nvar messages = pgTable(\"messages\", {\n  id: serial(\"id\").primaryKey(),\n  senderId: varchar(\"sender_id\").notNull().references(() => users.id),\n  receiverId: varchar(\"receiver_id\").notNull().references(() => users.id),\n  content: text(\"content\").notNull(),\n  jobId: integer(\"job_id\").references(() => jobs.id),\n  // Optional job context\n  proposalId: integer(\"proposal_id\").references(() => proposals.id),\n  // Optional proposal context\n  read: boolean(\"read\").default(false),\n  createdAt: timestamp(\"created_at\").defaultNow()\n});\nvar contracts = pgTable(\"contracts\", {\n  id: serial(\"id\").primaryKey(),\n  jobId: integer(\"job_id\").notNull().references(() => jobs.id),\n  freelancerId: varchar(\"freelancer_id\").notNull().references(() => users.id),\n  clientId: varchar(\"client_id\").notNull().references(() => users.id),\n  proposalId: integer(\"proposal_id\").notNull().references(() => proposals.id),\n  status: varchar(\"status\").notNull().default(\"active\"),\n  // 'active', 'completed', 'cancelled'\n  totalEarnings: decimal(\"total_earnings\", { precision: 10, scale: 2 }).default(\"0\"),\n  hoursWorked: decimal(\"hours_worked\", { precision: 10, scale: 2 }).default(\"0\"),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  updatedAt: timestamp(\"updated_at\").defaultNow()\n});\nvar usersRelations = relations(users, ({ many }) => ({\n  jobsAsClient: many(jobs),\n  proposals: many(proposals),\n  sentMessages: many(messages, { relationName: \"sentMessages\" }),\n  receivedMessages: many(messages, { relationName: \"receivedMessages\" }),\n  contractsAsFreelancer: many(contracts, { relationName: \"freelancerContracts\" }),\n  contractsAsClient: many(contracts, { relationName: \"clientContracts\" })\n}));\nvar jobsRelations = relations(jobs, ({ one, many }) => ({\n  client: one(users, {\n    fields: [jobs.clientId],\n    references: [users.id]\n  }),\n  proposals: many(proposals),\n  messages: many(messages),\n  contracts: many(contracts)\n}));\nvar proposalsRelations = relations(proposals, ({ one, many }) => ({\n  job: one(jobs, {\n    fields: [proposals.jobId],\n    references: [jobs.id]\n  }),\n  freelancer: one(users, {\n    fields: [proposals.freelancerId],\n    references: [users.id]\n  }),\n  messages: many(messages),\n  contracts: many(contracts)\n}));\nvar messagesRelations = relations(messages, ({ one }) => ({\n  sender: one(users, {\n    fields: [messages.senderId],\n    references: [users.id],\n    relationName: \"sentMessages\"\n  }),\n  receiver: one(users, {\n    fields: [messages.receiverId],\n    references: [users.id],\n    relationName: \"receivedMessages\"\n  }),\n  job: one(jobs, {\n    fields: [messages.jobId],\n    references: [jobs.id]\n  }),\n  proposal: one(proposals, {\n    fields: [messages.proposalId],\n    references: [proposals.id]\n  })\n}));\nvar contractsRelations = relations(contracts, ({ one }) => ({\n  job: one(jobs, {\n    fields: [contracts.jobId],\n    references: [jobs.id]\n  }),\n  freelancer: one(users, {\n    fields: [contracts.freelancerId],\n    references: [users.id],\n    relationName: \"freelancerContracts\"\n  }),\n  client: one(users, {\n    fields: [contracts.clientId],\n    references: [users.id],\n    relationName: \"clientContracts\"\n  }),\n  proposal: one(proposals, {\n    fields: [contracts.proposalId],\n    references: [proposals.id]\n  })\n}));\nvar adminStats = pgTable(\"admin_stats\", {\n  id: serial(\"id\").primaryKey(),\n  totalUsers: integer(\"total_users\").default(0),\n  totalJobs: integer(\"total_jobs\").default(0),\n  totalProposals: integer(\"total_proposals\").default(0),\n  totalContracts: integer(\"total_contracts\").default(0),\n  totalRevenue: decimal(\"total_revenue\", { precision: 12, scale: 2 }).default(\"0\"),\n  updatedAt: timestamp(\"updated_at\").defaultNow()\n});\nvar userSuspensions = pgTable(\"user_suspensions\", {\n  id: serial(\"id\").primaryKey(),\n  userId: varchar(\"user_id\").notNull().references(() => users.id),\n  adminId: varchar(\"admin_id\").notNull().references(() => users.id),\n  reason: text(\"reason\").notNull(),\n  suspendedUntil: timestamp(\"suspended_until\"),\n  isActive: boolean(\"is_active\").default(true),\n  createdAt: timestamp(\"created_at\").defaultNow()\n});\nvar insertUserSchema = createInsertSchema(users).omit({\n  id: true,\n  createdAt: true,\n  updatedAt: true\n});\nvar insertSuspensionSchema = createInsertSchema(userSuspensions).omit({\n  id: true,\n  createdAt: true\n});\nvar insertJobSchema = createInsertSchema(jobs).omit({\n  id: true,\n  proposalCount: true,\n  createdAt: true,\n  updatedAt: true\n}).extend({\n  budgetMin: z.union([z.string(), z.number()]).transform((val) => Number(val)).optional(),\n  budgetMax: z.union([z.string(), z.number()]).transform((val) => Number(val)).optional(),\n  hourlyRate: z.union([z.string(), z.number()]).transform((val) => Number(val)).optional()\n});\nvar insertProposalSchema = createInsertSchema(proposals).omit({\n  id: true,\n  createdAt: true,\n  updatedAt: true\n}).extend({\n  proposedRate: z.union([z.string(), z.number()]).transform((val) => Number(val))\n});\nvar insertMessageSchema = createInsertSchema(messages).omit({\n  id: true,\n  createdAt: true\n});\nvar insertContractSchema = createInsertSchema(contracts).omit({\n  id: true,\n  createdAt: true,\n  updatedAt: true\n});\n\n// server/db.ts\nimport { Pool, neonConfig } from \"@neondatabase/serverless\";\nimport { drizzle } from \"drizzle-orm/neon-serverless\";\nimport ws from \"ws\";\nneonConfig.webSocketConstructor = ws;\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\"\n  );\n}\nvar pool = new Pool({ connectionString: process.env.DATABASE_URL });\nvar db = drizzle({ client: pool, schema: schema_exports });\n\n// server/storage.ts\nimport { eq, desc, asc, and, or, like, count, sql as sql2 } from \"drizzle-orm\";\nvar DatabaseStorage = class {\n  // User operations (mandatory for Replit Auth)\n  async getUser(id) {\n    const [user] = await db.select().from(users).where(eq(users.id, id));\n    return user;\n  }\n  async upsertUser(userData) {\n    const [user] = await db.insert(users).values(userData).onConflictDoUpdate({\n      target: users.id,\n      set: {\n        ...userData,\n        updatedAt: /* @__PURE__ */ new Date()\n      }\n    }).returning();\n    return user;\n  }\n  // Job operations\n  async createJob(job) {\n    const [newJob] = await db.insert(jobs).values(job).returning();\n    return newJob;\n  }\n  async getJobs(filters = {}) {\n    const { limit = 10, offset = 0, category, budgetMin, budgetMax, experienceLevel, search, skills } = filters;\n    let query = db.select().from(jobs);\n    let countQuery = db.select({ count: count() }).from(jobs);\n    const conditions = [\n      eq(jobs.status, \"open\"),\n      // Exclude jobs that have completed contracts using NOT EXISTS\n      sql2`NOT EXISTS (\n        SELECT 1 FROM ${contracts} \n        WHERE ${contracts.jobId} = ${jobs.id} \n        AND ${contracts.status} = 'completed'\n      )`\n    ];\n    if (category && category !== \"all\") {\n      conditions.push(eq(jobs.category, category));\n    }\n    if (budgetMin !== void 0) {\n      conditions.push(sql2`${jobs.budgetMin} >= ${budgetMin}`);\n    }\n    if (budgetMax !== void 0) {\n      conditions.push(sql2`${jobs.budgetMax} <= ${budgetMax}`);\n    }\n    if (experienceLevel) {\n      conditions.push(eq(jobs.experienceLevel, experienceLevel));\n    }\n    if (search) {\n      conditions.push(\n        or(\n          like(jobs.title, `%${search}%`),\n          like(jobs.description, `%${search}%`)\n        )\n      );\n    }\n    if (skills && skills.length > 0) {\n      conditions.push(sql2`${jobs.skills} && ${skills}`);\n    }\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions));\n      countQuery = countQuery.where(and(...conditions));\n    }\n    const [jobResults, countResult] = await Promise.all([\n      query.orderBy(desc(jobs.createdAt)).limit(limit).offset(offset),\n      countQuery\n    ]);\n    return {\n      jobs: jobResults,\n      total: countResult[0].count\n    };\n  }\n  async getJob(id) {\n    const [job] = await db.select().from(jobs).where(eq(jobs.id, id));\n    return job;\n  }\n  async getJobWithClient(id) {\n    const [result] = await db.select().from(jobs).leftJoin(users, eq(jobs.clientId, users.id)).where(eq(jobs.id, id));\n    if (!result || !result.users) return void 0;\n    return {\n      ...result.jobs,\n      client: result.users\n    };\n  }\n  async updateJob(id, updates) {\n    const [job] = await db.update(jobs).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(jobs.id, id)).returning();\n    return job;\n  }\n  async deleteJob(id) {\n    await db.delete(jobs).where(eq(jobs.id, id));\n  }\n  async getJobsByClient(clientId) {\n    return await db.select().from(jobs).where(eq(jobs.clientId, clientId)).orderBy(desc(jobs.createdAt));\n  }\n  // Proposal operations\n  async createProposal(proposal) {\n    const [newProposal] = await db.insert(proposals).values(proposal).returning();\n    await db.update(jobs).set({ proposalCount: sql2`${jobs.proposalCount} + 1` }).where(eq(jobs.id, proposal.jobId));\n    return newProposal;\n  }\n  async getProposalsByJob(jobId) {\n    const results = await db.select().from(proposals).leftJoin(users, eq(proposals.freelancerId, users.id)).where(eq(proposals.jobId, jobId)).orderBy(desc(proposals.createdAt));\n    return results.map((result) => ({\n      ...result.proposals,\n      freelancer: result.users\n    }));\n  }\n  async getProposalsByFreelancer(freelancerId) {\n    const results = await db.select().from(proposals).leftJoin(jobs, eq(proposals.jobId, jobs.id)).where(eq(proposals.freelancerId, freelancerId)).orderBy(desc(proposals.createdAt));\n    return results.map((result) => ({\n      ...result.proposals,\n      job: result.jobs\n    }));\n  }\n  async getProposal(id) {\n    const [proposal] = await db.select().from(proposals).where(eq(proposals.id, id));\n    return proposal;\n  }\n  async updateProposal(id, updates) {\n    const [proposal] = await db.update(proposals).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(proposals.id, id)).returning();\n    return proposal;\n  }\n  async deleteProposal(id) {\n    const proposal = await this.getProposal(id);\n    if (proposal) {\n      await db.delete(proposals).where(eq(proposals.id, id));\n      await db.update(jobs).set({ proposalCount: sql2`${jobs.proposalCount} - 1` }).where(eq(jobs.id, proposal.jobId));\n    }\n  }\n  // Message operations\n  async createMessage(message) {\n    const [newMessage] = await db.insert(messages).values(message).returning();\n    return newMessage;\n  }\n  async getConversations(userId) {\n    const userMessages = await db.select().from(messages).where(or(eq(messages.senderId, userId), eq(messages.receiverId, userId))).orderBy(desc(messages.createdAt));\n    const conversationMap = /* @__PURE__ */ new Map();\n    for (const message of userMessages) {\n      const otherUserId = message.senderId === userId ? message.receiverId : message.senderId;\n      if (!conversationMap.has(otherUserId)) {\n        conversationMap.set(otherUserId, message);\n      }\n    }\n    const conversations = [];\n    for (const [otherUserId, lastMessage] of Array.from(conversationMap.entries())) {\n      const otherUser = await this.getUser(otherUserId);\n      if (otherUser) {\n        const [unreadResult] = await db.select({ count: count() }).from(messages).where(\n          and(\n            eq(messages.senderId, otherUserId),\n            eq(messages.receiverId, userId),\n            eq(messages.read, false)\n          )\n        );\n        conversations.push({\n          otherUserId,\n          otherUser,\n          lastMessage,\n          unreadCount: unreadResult.count\n        });\n      }\n    }\n    conversations.sort(\n      (a, b) => new Date(b.lastMessage.createdAt).getTime() - new Date(a.lastMessage.createdAt).getTime()\n    );\n    return conversations;\n  }\n  async getMessagesBetweenUsers(user1Id, user2Id, limit = 50) {\n    return await db.select().from(messages).where(\n      or(\n        and(eq(messages.senderId, user1Id), eq(messages.receiverId, user2Id)),\n        and(eq(messages.senderId, user2Id), eq(messages.receiverId, user1Id))\n      )\n    ).orderBy(asc(messages.createdAt)).limit(limit);\n  }\n  async markMessagesAsRead(receiverId, senderId) {\n    await db.update(messages).set({ read: true }).where(\n      and(\n        eq(messages.receiverId, receiverId),\n        eq(messages.senderId, senderId),\n        eq(messages.read, false)\n      )\n    );\n  }\n  async getUnreadMessageCount(userId) {\n    const [result] = await db.select({ count: count() }).from(messages).where(\n      and(\n        eq(messages.receiverId, userId),\n        eq(messages.read, false)\n      )\n    );\n    return result.count;\n  }\n  // Contract operations\n  async createContract(contract) {\n    const [newContract] = await db.insert(contracts).values(contract).returning();\n    await db.update(jobs).set({ status: \"in_progress\", updatedAt: /* @__PURE__ */ new Date() }).where(eq(jobs.id, contract.jobId));\n    await db.update(proposals).set({ status: \"accepted\", updatedAt: /* @__PURE__ */ new Date() }).where(eq(proposals.id, contract.proposalId));\n    return newContract;\n  }\n  async getContractsByFreelancer(freelancerId) {\n    const results = await db.select().from(contracts).leftJoin(jobs, eq(contracts.jobId, jobs.id)).leftJoin(users, eq(contracts.clientId, users.id)).where(eq(contracts.freelancerId, freelancerId)).orderBy(desc(contracts.createdAt));\n    return results.map((result) => ({\n      ...result.contracts,\n      job: result.jobs,\n      client: result.users\n    }));\n  }\n  async getContractsByClient(clientId) {\n    const results = await db.select().from(contracts).leftJoin(jobs, eq(contracts.jobId, jobs.id)).leftJoin(users, eq(contracts.freelancerId, users.id)).where(eq(contracts.clientId, clientId)).orderBy(desc(contracts.createdAt));\n    return results.map((result) => ({\n      ...result.contracts,\n      job: result.jobs,\n      freelancer: result.users\n    }));\n  }\n  async updateContract(id, updates) {\n    const [contract] = await db.update(contracts).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(contracts.id, id)).returning();\n    return contract;\n  }\n  // Admin operations\n  async getAllUsers(filters = {}) {\n    const { limit = 50, offset = 0, userType, search, status } = filters;\n    let query = db.select().from(users);\n    let countQuery = db.select({ count: count() }).from(users);\n    const conditions = [];\n    if (userType && userType !== \"all\") {\n      conditions.push(eq(users.userType, userType));\n    }\n    if (search) {\n      conditions.push(\n        or(\n          like(users.firstName, `%${search}%`),\n          like(users.lastName, `%${search}%`),\n          like(users.email, `%${search}%`)\n        )\n      );\n    }\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions));\n      countQuery = countQuery.where(and(...conditions));\n    }\n    const [userResults, countResult] = await Promise.all([\n      query.orderBy(desc(users.createdAt)).limit(limit).offset(offset),\n      countQuery\n    ]);\n    return {\n      users: userResults,\n      total: countResult[0].count\n    };\n  }\n  async getAllJobs(filters = {}) {\n    const { limit = 50, offset = 0, status, search } = filters;\n    let query = db.select().from(jobs).leftJoin(users, eq(jobs.clientId, users.id));\n    let countQuery = db.select({ count: count() }).from(jobs);\n    const conditions = [];\n    if (status && status !== \"all\") {\n      conditions.push(eq(jobs.status, status));\n    }\n    if (search) {\n      conditions.push(\n        or(\n          like(jobs.title, `%${search}%`),\n          like(jobs.description, `%${search}%`)\n        )\n      );\n    }\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions));\n      countQuery = countQuery.where(and(...conditions));\n    }\n    const [jobResults, countResult] = await Promise.all([\n      query.orderBy(desc(jobs.createdAt)).limit(limit).offset(offset),\n      countQuery\n    ]);\n    return {\n      jobs: jobResults.map((result) => ({\n        ...result.jobs,\n        client: result.users\n      })),\n      total: countResult[0].count\n    };\n  }\n  async getAllProposals(filters = {}) {\n    const { limit = 50, offset = 0, status } = filters;\n    let query = db.select().from(proposals).leftJoin(jobs, eq(proposals.jobId, jobs.id)).leftJoin(users, eq(proposals.freelancerId, users.id));\n    let countQuery = db.select({ count: count() }).from(proposals);\n    const conditions = [];\n    if (status && status !== \"all\") {\n      conditions.push(eq(proposals.status, status));\n    }\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions));\n      countQuery = countQuery.where(and(...conditions));\n    }\n    const [proposalResults, countResult] = await Promise.all([\n      query.orderBy(desc(proposals.createdAt)).limit(limit).offset(offset),\n      countQuery\n    ]);\n    return {\n      proposals: proposalResults.map((result) => ({\n        ...result.proposals,\n        job: result.jobs,\n        freelancer: result.users\n      })),\n      total: countResult[0].count\n    };\n  }\n  async getAdminStats() {\n    let [stats] = await db.select().from(adminStats).limit(1);\n    if (!stats) {\n      await this.updateAdminStats();\n      [stats] = await db.select().from(adminStats).limit(1);\n    }\n    return stats;\n  }\n  async updateAdminStats() {\n    const [userCount] = await db.select({ count: count() }).from(users);\n    const [jobCount] = await db.select({ count: count() }).from(jobs);\n    const [proposalCount] = await db.select({ count: count() }).from(proposals);\n    const [contractCount] = await db.select({ count: count() }).from(contracts);\n    const [revenueResult] = await db.select({ total: sql2`COALESCE(SUM(${contracts.totalEarnings}), 0)` }).from(contracts);\n    const statsData = {\n      totalUsers: userCount.count,\n      totalJobs: jobCount.count,\n      totalProposals: proposalCount.count,\n      totalContracts: contractCount.count,\n      totalRevenue: revenueResult.total,\n      updatedAt: /* @__PURE__ */ new Date()\n    };\n    const [existingStats] = await db.select().from(adminStats).limit(1);\n    if (existingStats) {\n      await db.update(adminStats).set(statsData).where(eq(adminStats.id, existingStats.id));\n    } else {\n      await db.insert(adminStats).values(statsData);\n    }\n  }\n  async suspendUser(suspension) {\n    const [newSuspension] = await db.insert(userSuspensions).values(suspension).returning();\n    return newSuspension;\n  }\n  async unsuspendUser(userId) {\n    await db.update(userSuspensions).set({ isActive: false }).where(and(eq(userSuspensions.userId, userId), eq(userSuspensions.isActive, true)));\n  }\n  async getUserSuspensions(userId) {\n    return await db.select().from(userSuspensions).where(eq(userSuspensions.userId, userId)).orderBy(desc(userSuspensions.createdAt));\n  }\n  async deleteUser(userId) {\n    await db.transaction(async (tx) => {\n      await tx.delete(userSuspensions).where(eq(userSuspensions.userId, userId));\n      await tx.delete(messages).where(\n        or(eq(messages.senderId, userId), eq(messages.receiverId, userId))\n      );\n      await tx.delete(contracts).where(\n        or(eq(contracts.freelancerId, userId), eq(contracts.clientId, userId))\n      );\n      await tx.delete(proposals).where(eq(proposals.freelancerId, userId));\n      await tx.delete(jobs).where(eq(jobs.clientId, userId));\n      await tx.delete(users).where(eq(users.id, userId));\n    });\n  }\n  async updateUserRole(userId, userType) {\n    const [user] = await db.update(users).set({ userType, updatedAt: /* @__PURE__ */ new Date() }).where(eq(users.id, userId)).returning();\n    return user;\n  }\n};\nvar DB_TYPE = process.env.DB_TYPE || \"postgresql\";\nvar sqlServerStorage2 = null;\nif (DB_TYPE === \"sqlserver\") {\n  try {\n    const { sqlServerStorage: sqlServerStorageImpl } = (init_storage_sqlserver(), __toCommonJS(storage_sqlserver_exports));\n    sqlServerStorage2 = sqlServerStorageImpl;\n  } catch (error) {\n    console.warn(\"SQL Server storage not available, falling back to PostgreSQL\");\n  }\n}\nvar storage = DB_TYPE === \"sqlserver\" && sqlServerStorage2 ? sqlServerStorage2 : new DatabaseStorage();\n\n// server/replitAuth.ts\nimport * as client from \"openid-client\";\nimport { Strategy } from \"openid-client/passport\";\nimport passport from \"passport\";\nimport session from \"express-session\";\nimport memoize from \"memoizee\";\nimport connectPg from \"connect-pg-simple\";\nif (!process.env.REPLIT_DOMAINS) {\n  throw new Error(\"Environment variable REPLIT_DOMAINS not provided\");\n}\nvar getOidcConfig = memoize(\n  async () => {\n    return await client.discovery(\n      new URL(process.env.ISSUER_URL ?? \"https://replit.com/oidc\"),\n      process.env.REPL_ID\n    );\n  },\n  { maxAge: 3600 * 1e3 }\n);\nfunction getSession() {\n  const sessionTtl = 7 * 24 * 60 * 60 * 1e3;\n  const pgStore = connectPg(session);\n  const sessionStore = new pgStore({\n    conString: process.env.DATABASE_URL,\n    createTableIfMissing: false,\n    ttl: sessionTtl,\n    tableName: \"sessions\"\n  });\n  return session({\n    secret: process.env.SESSION_SECRET,\n    store: sessionStore,\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n      httpOnly: true,\n      secure: true,\n      maxAge: sessionTtl\n    }\n  });\n}\nfunction updateUserSession(user, tokens) {\n  user.claims = tokens.claims();\n  user.access_token = tokens.access_token;\n  user.refresh_token = tokens.refresh_token;\n  user.expires_at = user.claims?.exp;\n}\nasync function upsertUser(claims) {\n  await storage.upsertUser({\n    id: claims[\"sub\"],\n    email: claims[\"email\"],\n    firstName: claims[\"first_name\"],\n    lastName: claims[\"last_name\"],\n    profileImageUrl: claims[\"profile_image_url\"],\n    userType: \"client\"\n    // Default to client type, users can change this later\n  });\n}\nasync function setupAuth(app2) {\n  app2.set(\"trust proxy\", 1);\n  app2.use(getSession());\n  app2.use(passport.initialize());\n  app2.use(passport.session());\n  const config2 = await getOidcConfig();\n  const verify = async (tokens, verified) => {\n    const user = {};\n    updateUserSession(user, tokens);\n    await upsertUser(tokens.claims());\n    verified(null, user);\n  };\n  for (const domain of process.env.REPLIT_DOMAINS.split(\",\")) {\n    const strategy = new Strategy(\n      {\n        name: `replitauth:${domain}`,\n        config: config2,\n        scope: \"openid email profile offline_access\",\n        callbackURL: `https://${domain}/api/callback`\n      },\n      verify\n    );\n    passport.use(strategy);\n  }\n  passport.serializeUser((user, cb) => cb(null, user));\n  passport.deserializeUser((user, cb) => cb(null, user));\n  app2.get(\"/api/login\", (req, res, next) => {\n    passport.authenticate(`replitauth:${req.hostname}`, {\n      prompt: \"login consent\",\n      scope: [\"openid\", \"email\", \"profile\", \"offline_access\"]\n    })(req, res, next);\n  });\n  app2.get(\"/api/callback\", (req, res, next) => {\n    passport.authenticate(`replitauth:${req.hostname}`, {\n      successReturnToOrRedirect: \"/\",\n      failureRedirect: \"/api/login\"\n    })(req, res, next);\n  });\n  app2.get(\"/api/logout\", (req, res) => {\n    req.logout(() => {\n      res.redirect(\n        client.buildEndSessionUrl(config2, {\n          client_id: process.env.REPL_ID,\n          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`\n        }).href\n      );\n    });\n  });\n}\nvar isAuthenticated = async (req, res, next) => {\n  const user = req.user;\n  if (!req.isAuthenticated() || !user.expires_at) {\n    return res.status(401).json({ message: \"Unauthorized\" });\n  }\n  const now = Math.floor(Date.now() / 1e3);\n  if (now <= user.expires_at) {\n    return next();\n  }\n  const refreshToken = user.refresh_token;\n  if (!refreshToken) {\n    res.status(401).json({ message: \"Unauthorized\" });\n    return;\n  }\n  try {\n    const config2 = await getOidcConfig();\n    const tokenResponse = await client.refreshTokenGrant(config2, refreshToken);\n    updateUserSession(user, tokenResponse);\n    return next();\n  } catch (error) {\n    res.status(401).json({ message: \"Unauthorized\" });\n    return;\n  }\n};\n\n// server/routes.ts\nimport { z as z2 } from \"zod\";\nasync function registerRoutes(app2) {\n  await setupAuth(app2);\n  app2.get(\"/api/auth/user\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const user = await storage.getUser(userId);\n      if (!user) {\n        return res.status(404).json({ message: \"User not found\" });\n      }\n      const userResponse = {\n        ...user,\n        userType: user.userType || \"client\"\n      };\n      console.log(\"User response being sent:\", userResponse);\n      res.json(userResponse);\n    } catch (error) {\n      console.error(\"Error fetching user:\", error);\n      res.status(500).json({ message: \"Failed to fetch user\" });\n    }\n  });\n  app2.patch(\"/api/auth/user\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const updates = req.body;\n      const cleanedUpdates = {\n        ...updates,\n        hourlyRate: updates.hourlyRate === \"\" || updates.hourlyRate === void 0 ? null : parseFloat(updates.hourlyRate)\n      };\n      Object.keys(cleanedUpdates).forEach((key) => {\n        if (cleanedUpdates[key] === void 0) {\n          delete cleanedUpdates[key];\n        }\n      });\n      const user = await storage.upsertUser({ id: userId, ...cleanedUpdates });\n      console.log(\"User updated successfully:\", user);\n      res.json(user);\n    } catch (error) {\n      console.error(\"Error updating user:\", error);\n      res.status(500).json({ message: \"Failed to update user\" });\n    }\n  });\n  app2.post(\"/api/auth/upload-photo\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const { imageData } = req.body;\n      if (!imageData) {\n        return res.status(400).json({ message: \"No image data provided\" });\n      }\n      const user = await storage.upsertUser({\n        id: userId,\n        profileImageUrl: imageData\n      });\n      res.json({ profileImageUrl: user.profileImageUrl });\n    } catch (error) {\n      console.error(\"Error uploading photo:\", error);\n      res.status(500).json({ message: \"Failed to upload photo\" });\n    }\n  });\n  app2.post(\"/api/auth/switch-type\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const { userType } = req.body;\n      if (![\"client\", \"freelancer\", \"admin\"].includes(userType)) {\n        return res.status(400).json({ message: \"Invalid user type\" });\n      }\n      const user = await storage.upsertUser({\n        id: userId,\n        userType\n      });\n      res.json({ userType: user.userType });\n    } catch (error) {\n      console.error(\"Error switching user type:\", error);\n      res.status(500).json({ message: \"Failed to switch user type\" });\n    }\n  });\n  app2.post(\"/api/jobs\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const user = await storage.getUser(userId);\n      if (user?.userType !== \"client\") {\n        return res.status(403).json({ message: \"Only clients can post jobs\" });\n      }\n      const jobData = insertJobSchema.parse({ ...req.body, clientId: userId });\n      const job = await storage.createJob(jobData);\n      res.json(job);\n    } catch (error) {\n      console.error(\"Error creating job:\", error);\n      if (error instanceof z2.ZodError) {\n        return res.status(400).json({ message: \"Invalid job data\", errors: error.errors });\n      }\n      res.status(500).json({ message: \"Failed to create job\" });\n    }\n  });\n  app2.get(\"/api/jobs\", async (req, res) => {\n    try {\n      const {\n        category,\n        budgetMin,\n        budgetMax,\n        experienceLevel,\n        search,\n        skills,\n        limit = \"10\",\n        offset = \"0\"\n      } = req.query;\n      const filters = {\n        category,\n        budgetMin: budgetMin ? Number(budgetMin) : void 0,\n        budgetMax: budgetMax ? Number(budgetMax) : void 0,\n        experienceLevel,\n        search,\n        skills: skills ? skills.split(\",\") : void 0,\n        limit: Number(limit),\n        offset: Number(offset)\n      };\n      const result = await storage.getJobs(filters);\n      res.json(result);\n    } catch (error) {\n      console.error(\"Error fetching jobs:\", error);\n      res.status(500).json({ message: \"Failed to fetch jobs\" });\n    }\n  });\n  app2.get(\"/api/jobs/:id\", async (req, res) => {\n    try {\n      const jobId = Number(req.params.id);\n      const job = await storage.getJobWithClient(jobId);\n      if (!job) {\n        return res.status(404).json({ message: \"Job not found\" });\n      }\n      res.json(job);\n    } catch (error) {\n      console.error(\"Error fetching job:\", error);\n      res.status(500).json({ message: \"Failed to fetch job\" });\n    }\n  });\n  app2.get(\"/api/my-jobs\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const jobs2 = await storage.getJobsByClient(userId);\n      res.json(jobs2);\n    } catch (error) {\n      console.error(\"Error fetching user jobs:\", error);\n      res.status(500).json({ message: \"Failed to fetch jobs\" });\n    }\n  });\n  app2.patch(\"/api/jobs/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const jobId = Number(req.params.id);\n      const job = await storage.getJob(jobId);\n      if (!job || job.clientId !== userId) {\n        return res.status(404).json({ message: \"Job not found or unauthorized\" });\n      }\n      const updatedJob = await storage.updateJob(jobId, req.body);\n      res.json(updatedJob);\n    } catch (error) {\n      console.error(\"Error updating job:\", error);\n      res.status(500).json({ message: \"Failed to update job\" });\n    }\n  });\n  app2.delete(\"/api/jobs/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const jobId = Number(req.params.id);\n      const job = await storage.getJob(jobId);\n      if (!job || job.clientId !== userId) {\n        return res.status(404).json({ message: \"Job not found or unauthorized\" });\n      }\n      await storage.deleteJob(jobId);\n      res.json({ message: \"Job deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting job:\", error);\n      res.status(500).json({ message: \"Failed to delete job\" });\n    }\n  });\n  app2.post(\"/api/proposals\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const user = await storage.getUser(userId);\n      if (user?.userType !== \"freelancer\") {\n        return res.status(403).json({ message: \"Only freelancers can submit proposals\" });\n      }\n      const proposalData = insertProposalSchema.parse({ ...req.body, freelancerId: userId });\n      const proposal = await storage.createProposal(proposalData);\n      res.json(proposal);\n    } catch (error) {\n      console.error(\"Error creating proposal:\", error);\n      if (error instanceof z2.ZodError) {\n        return res.status(400).json({ message: \"Invalid proposal data\", errors: error.errors });\n      }\n      res.status(500).json({ message: \"Failed to create proposal\" });\n    }\n  });\n  app2.get(\"/api/jobs/:id/proposals\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const jobId = Number(req.params.id);\n      const job = await storage.getJob(jobId);\n      if (!job || job.clientId !== userId) {\n        return res.status(403).json({ message: \"Unauthorized to view proposals\" });\n      }\n      const proposals2 = await storage.getProposalsByJob(jobId);\n      res.json(proposals2);\n    } catch (error) {\n      console.error(\"Error fetching proposals:\", error);\n      res.status(500).json({ message: \"Failed to fetch proposals\" });\n    }\n  });\n  app2.get(\"/api/my-proposals\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const proposals2 = await storage.getProposalsByFreelancer(userId);\n      res.json(proposals2);\n    } catch (error) {\n      console.error(\"Error fetching user proposals:\", error);\n      res.status(500).json({ message: \"Failed to fetch proposals\" });\n    }\n  });\n  app2.patch(\"/api/proposals/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const proposalId = Number(req.params.id);\n      const proposal = await storage.getProposal(proposalId);\n      if (!proposal || proposal.freelancerId !== userId) {\n        return res.status(404).json({ message: \"Proposal not found or unauthorized\" });\n      }\n      const updatedProposal = await storage.updateProposal(proposalId, req.body);\n      res.json(updatedProposal);\n    } catch (error) {\n      console.error(\"Error updating proposal:\", error);\n      res.status(500).json({ message: \"Failed to update proposal\" });\n    }\n  });\n  app2.post(\"/api/messages\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const messageData = insertMessageSchema.parse({ ...req.body, senderId: userId });\n      const message = await storage.createMessage(messageData);\n      res.json(message);\n    } catch (error) {\n      console.error(\"Error creating message:\", error);\n      if (error instanceof z2.ZodError) {\n        return res.status(400).json({ message: \"Invalid message data\", errors: error.errors });\n      }\n      res.status(500).json({ message: \"Failed to create message\" });\n    }\n  });\n  app2.get(\"/api/conversations\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const conversations = await storage.getConversations(userId);\n      res.json(conversations);\n    } catch (error) {\n      console.error(\"Error fetching conversations:\", error);\n      res.status(500).json({ message: \"Failed to fetch conversations\" });\n    }\n  });\n  app2.get(\"/api/messages/:otherUserId\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const otherUserId = req.params.otherUserId;\n      const limit = req.query.limit ? Number(req.query.limit) : 50;\n      const messages2 = await storage.getMessagesBetweenUsers(userId, otherUserId, limit);\n      await storage.markMessagesAsRead(userId, otherUserId);\n      res.json(messages2);\n    } catch (error) {\n      console.error(\"Error fetching messages:\", error);\n      res.status(500).json({ message: \"Failed to fetch messages\" });\n    }\n  });\n  app2.get(\"/api/messages/unread/count\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const count2 = await storage.getUnreadMessageCount(userId);\n      res.json({ count: count2 });\n    } catch (error) {\n      console.error(\"Error fetching unread count:\", error);\n      res.status(500).json({ message: \"Failed to fetch unread count\" });\n    }\n  });\n  app2.post(\"/api/contracts\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const contractData = insertContractSchema.parse(req.body);\n      const job = await storage.getJob(contractData.jobId);\n      if (!job || job.clientId !== userId) {\n        return res.status(403).json({ message: \"Unauthorized to create contract\" });\n      }\n      const contract = await storage.createContract(contractData);\n      res.json(contract);\n    } catch (error) {\n      console.error(\"Error creating contract:\", error);\n      if (error instanceof z2.ZodError) {\n        return res.status(400).json({ message: \"Invalid contract data\", errors: error.errors });\n      }\n      res.status(500).json({ message: \"Failed to create contract\" });\n    }\n  });\n  app2.get(\"/api/my-contracts\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const user = await storage.getUser(userId);\n      let contracts2;\n      if (user?.userType === \"freelancer\") {\n        contracts2 = await storage.getContractsByFreelancer(userId);\n      } else {\n        contracts2 = await storage.getContractsByClient(userId);\n      }\n      res.json(contracts2);\n    } catch (error) {\n      console.error(\"Error fetching contracts:\", error);\n      res.status(500).json({ message: \"Failed to fetch contracts\" });\n    }\n  });\n  app2.patch(\"/api/contracts/:id\", isAuthenticated, async (req, res) => {\n    try {\n      const userId = req.user.claims.sub;\n      const contractId = Number(req.params.id);\n      const { status } = req.body;\n      const validStatuses = [\"pending\", \"active\", \"completed\", \"cancelled\"];\n      if (!validStatuses.includes(status)) {\n        return res.status(400).json({ message: \"Invalid contract status\" });\n      }\n      const contracts2 = await storage.getContractsByClient(userId);\n      const freelancerContracts = await storage.getContractsByFreelancer(userId);\n      const allUserContracts = [...contracts2, ...freelancerContracts];\n      const contract = allUserContracts.find((c) => c.id === contractId);\n      if (!contract) {\n        return res.status(404).json({ message: \"Contract not found or unauthorized\" });\n      }\n      if (status === \"completed\" && contract.clientId !== userId) {\n        return res.status(403).json({ message: \"Only clients can mark contracts as completed\" });\n      }\n      const updatedContract = await storage.updateContract(contractId, { status });\n      res.json(updatedContract);\n    } catch (error) {\n      console.error(\"Error updating contract:\", error);\n      res.status(500).json({ message: \"Failed to update contract\" });\n    }\n  });\n  const isAdmin = async (req, res, next) => {\n    try {\n      const userId = req.user?.claims?.sub;\n      if (!userId) {\n        return res.status(401).json({ message: \"Unauthorized\" });\n      }\n      const user = await storage.getUser(userId);\n      if (!user || user.userType !== \"admin\") {\n        return res.status(403).json({ message: \"Admin access required\" });\n      }\n      next();\n    } catch (error) {\n      console.error(\"Admin middleware error:\", error);\n      res.status(500).json({ message: \"Server error\" });\n    }\n  };\n  app2.get(\"/api/admin/stats\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const stats = await storage.getAdminStats();\n      res.json(stats);\n    } catch (error) {\n      console.error(\"Error fetching admin stats:\", error);\n      res.status(500).json({ message: \"Failed to fetch admin stats\" });\n    }\n  });\n  app2.post(\"/api/admin/stats/update\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      await storage.updateAdminStats();\n      const stats = await storage.getAdminStats();\n      res.json(stats);\n    } catch (error) {\n      console.error(\"Error updating admin stats:\", error);\n      res.status(500).json({ message: \"Failed to update admin stats\" });\n    }\n  });\n  app2.get(\"/api/admin/users\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { page = 1, limit = 20, userType, search } = req.query;\n      const offset = (parseInt(page) - 1) * parseInt(limit);\n      const result = await storage.getAllUsers({\n        userType,\n        search,\n        limit: parseInt(limit),\n        offset\n      });\n      res.json({\n        ...result,\n        page: parseInt(page),\n        totalPages: Math.ceil(result.total / parseInt(limit))\n      });\n    } catch (error) {\n      console.error(\"Error fetching users:\", error);\n      res.status(500).json({ message: \"Failed to fetch users\" });\n    }\n  });\n  app2.get(\"/api/admin/jobs\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { page = 1, limit = 20, status, search } = req.query;\n      const offset = (parseInt(page) - 1) * parseInt(limit);\n      const result = await storage.getAllJobs({\n        status,\n        search,\n        limit: parseInt(limit),\n        offset\n      });\n      res.json({\n        ...result,\n        page: parseInt(page),\n        totalPages: Math.ceil(result.total / parseInt(limit))\n      });\n    } catch (error) {\n      console.error(\"Error fetching jobs:\", error);\n      res.status(500).json({ message: \"Failed to fetch jobs\" });\n    }\n  });\n  app2.get(\"/api/admin/proposals\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { page = 1, limit = 20, status } = req.query;\n      const offset = (parseInt(page) - 1) * parseInt(limit);\n      const result = await storage.getAllProposals({\n        status,\n        limit: parseInt(limit),\n        offset\n      });\n      res.json({\n        ...result,\n        page: parseInt(page),\n        totalPages: Math.ceil(result.total / parseInt(limit))\n      });\n    } catch (error) {\n      console.error(\"Error fetching proposals:\", error);\n      res.status(500).json({ message: \"Failed to fetch proposals\" });\n    }\n  });\n  app2.post(\"/api/admin/users/:userId/suspend\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { userId } = req.params;\n      const { reason, suspendedUntil } = req.body;\n      const adminId = req.user.claims.sub;\n      if (!reason) {\n        return res.status(400).json({ message: \"Suspension reason is required\" });\n      }\n      const suspension = await storage.suspendUser({\n        userId,\n        adminId,\n        reason,\n        suspendedUntil: suspendedUntil ? new Date(suspendedUntil) : null\n      });\n      res.json(suspension);\n    } catch (error) {\n      console.error(\"Error suspending user:\", error);\n      res.status(500).json({ message: \"Failed to suspend user\" });\n    }\n  });\n  app2.post(\"/api/admin/users/:userId/unsuspend\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { userId } = req.params;\n      await storage.unsuspendUser(userId);\n      res.json({ message: \"User unsuspended successfully\" });\n    } catch (error) {\n      console.error(\"Error unsuspending user:\", error);\n      res.status(500).json({ message: \"Failed to unsuspend user\" });\n    }\n  });\n  app2.put(\"/api/admin/users/:userId/role\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { userId } = req.params;\n      const { userType } = req.body;\n      if (![\"freelancer\", \"client\", \"admin\"].includes(userType)) {\n        return res.status(400).json({ message: \"Invalid user type\" });\n      }\n      const user = await storage.updateUserRole(userId, userType);\n      res.json(user);\n    } catch (error) {\n      console.error(\"Error updating user role:\", error);\n      res.status(500).json({ message: \"Failed to update user role\" });\n    }\n  });\n  app2.delete(\"/api/admin/users/:userId\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { userId } = req.params;\n      await storage.deleteUser(userId);\n      res.json({ message: \"User deleted successfully\" });\n    } catch (error) {\n      console.error(\"Error deleting user:\", error);\n      res.status(500).json({ message: \"Failed to delete user\" });\n    }\n  });\n  app2.get(\"/api/admin/users/:userId/suspensions\", isAuthenticated, isAdmin, async (req, res) => {\n    try {\n      const { userId } = req.params;\n      const suspensions = await storage.getUserSuspensions(userId);\n      res.json(suspensions);\n    } catch (error) {\n      console.error(\"Error fetching user suspensions:\", error);\n      res.status(500).json({ message: \"Failed to fetch user suspensions\" });\n    }\n  });\n  const httpServer = createServer(app2);\n  return httpServer;\n}\n\n// server/vite.ts\nimport express from \"express\";\nimport fs from \"fs\";\nimport path2 from \"path\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\n\n// vite.config.ts\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\nvar vite_config_default = defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    ...process.env.NODE_ENV !== \"production\" && process.env.REPL_ID !== void 0 ? [\n      await import(\"@replit/vite-plugin-cartographer\").then(\n        (m) => m.cartographer()\n      )\n    ] : []\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(import.meta.dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(import.meta.dirname, \"shared\"),\n      \"@assets\": path.resolve(import.meta.dirname, \"attached_assets\")\n    }\n  },\n  root: path.resolve(import.meta.dirname, \"client\"),\n  build: {\n    outDir: path.resolve(import.meta.dirname, \"dist/public\"),\n    emptyOutDir: true\n  },\n  server: {\n    fs: {\n      strict: true,\n      deny: [\"**/.*\"]\n    }\n  }\n});\n\n// server/vite.ts\nimport { nanoid } from \"nanoid\";\nvar viteLogger = createLogger();\nfunction log(message, source = \"express\") {\n  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true\n  });\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\nasync function setupVite(app2, server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    allowedHosts: true\n  };\n  const vite = await createViteServer({\n    ...vite_config_default,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      }\n    },\n    server: serverOptions,\n    appType: \"custom\"\n  });\n  app2.use(vite.middlewares);\n  app2.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n    try {\n      const clientTemplate = path2.resolve(\n        import.meta.dirname,\n        \"..\",\n        \"client\",\n        \"index.html\"\n      );\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e);\n      next(e);\n    }\n  });\n}\nfunction serveStatic(app2) {\n  const distPath = path2.resolve(import.meta.dirname, \"public\");\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`\n    );\n  }\n  app2.use(express.static(distPath));\n  app2.use(\"*\", (_req, res) => {\n    res.sendFile(path2.resolve(distPath, \"index.html\"));\n  });\n}\n\n// server/index.ts\nvar app = express2();\napp.use(express2.json());\napp.use(express2.urlencoded({ extended: false }));\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path3 = req.path;\n  let capturedJsonResponse = void 0;\n  const originalResJson = res.json;\n  res.json = function(bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path3.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"\\u2026\";\n      }\n      log(logLine);\n    }\n  });\n  next();\n});\n(async () => {\n  const server = await registerRoutes(app);\n  app.use((err, _req, res, _next) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n    res.status(status).json({ message });\n    throw err;\n  });\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n  const port = 5e3;\n  server.listen({\n    port,\n    host: \"0.0.0.0\",\n    reusePort: true\n  }, () => {\n    log(`serving on port ${port}`);\n  });\n})();\n"
